
* An experiment on Emacs minor modes
Decided to learn how minor modes in emacs works and how they are created. Following is the result of this  experiment.

* What is a mode?
Modes (editing modes) in emacs are used to alters how emacs behaves in some useful ways.Modes are categorized as being either major or minor. Major mode provides means for working with particular file type (.org, .c .pdf etc) or buffers of none-file type (shell etc). Each buffer allways uses a single major mode at any time. Minor modes are independent modes that associates some additional behaviour  to file or buffer type. By independt we mean that they are not dependent on other modes neither major or minor ones and as such can be used independently of other modes. Minor modes can be turned on and off as we you wish you can have any number of minor modes in use for each buffer. Minor modes  can be either buffer-local or global. Global modes when in use are active in all your buffers wheras buffer local modes are only active for the buffers you you have specifically activated the mode for.Examples of minor modes are show-paren-mode, display-line-number-mode and cwarn-mode.

* Creating   a minor mode
Turning your code/package into a minor mode  could  be done using  the =define-minor-mode= mode macro. But to get a better understanding  of how minor modes work and are setup I decided to do it manually. To do so you need a bit of boilerplate code  following a few conventions (hence the macro).
We need

- a variable naming the mode ending with =-mode=
- a function with same name as variable (ELisp has different namespaces for functions and variables)

  That's really are all that is needed to create minor mode but in addition we can also   
   
- Enable keymaps by adding entries in =minor-mode-map-alist=. Entries in the list are  pairs of minor-mode symbols and keymaps.
- Enable hooks by creating  variable  with following convention =modename-mode-hook=.  This could initially be set to nil. running the hooks can be done using =run-hooks=
 - enable lighter for minor-mode-alist again using minor mode variable symbol and

Minor modes can be global or associtiated with specific buffer.  In case you want to to be associated with local buffer we need to make the minor-mode variable buffer local. This could be done using the =make-variable-buffer-local= command. I've comment out that part in the below code as i wanted this minor-mode to be global.  I left the comment so you can se how you could define the mode variable and make it buffer local in one shot.

#+begin_src emacs-lisp
;; (make-variable-buffer-local
(defvar jv-basic-edit-mode nil "Toggle jv-edit-basic-mode")
;; )
#+end_src

=defvar= is Elisp special form. Special form means that the expression is evaluated in an out  of the ordninary way. That is it's not evaluated as "normal" expression but using different rules than those applied normally. consider ( + 2  3)  this is just combination consisting of symbols +, 2 and 3. Such expressions follow the rule to first evaluating subsexpressions (2 and 3) and apply the procedure (value of left most symbol) to the arguments which in this case are the evaluated to numbers 2 and 3. =defvar=  on the other hand user special rules for evaluating the expression. In above cas =jv-basic-edit-mode=  is a symbol for variable and is not  evaluated. Insted third thing in combination =nil= is evalueted and bound to the variable and last string is consider to be documentation string which is bound to symbols variable-documentaion string. =nil=  is just the empty list and is used to signify that variable has no value at the moment. =nil=  is also used to mean false sometimes. ugh  this explanation is a bit convulated rewrite...

Anyway you can just think of defvar as way to define a variable  with attached documenations string. 

Next we define the variable for to hold mode specific keybindings. 
#+begin_src emacs-lisp
(defvar jv-basic-edit-mode-map (make-sparse-keymap) "The keymap for jv-edit-basic-mode")
#+end_src

=Keymap= is special internal data structure in ELisp which can be used for binding commands to input events and are used for keylookup. Modes can use keymaps to associated mode specific keys to actions.   Keymaps can contain different kinds of elements one such element is  a char-table. A keymap containing a char-table is called a full keymap. char-tables is an space effective way of recording lots of keybindings. The element whos index is d would be the binding for d.  A =sparse-keymap=  does not contain  char-table and is usually what you need and would use.  There is a lot more to know about keybinding and keymaps if you want learn more see
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Keymap-Basics.html][keymap basics]] and [[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][masetring key bindings]]. 


;; Hooks on attached to this list will be run whenever mode is activated/deactivated
#+begin_src emacs-lisp
(defvar jv-basic-edit-mode-hook nil "The hook for jv-basic-edit-mode")
#+end_src


#+begin_src emacs-lisp
(define-key jv-basic-edit-mode-map (kbd "C-<return>") 'open-newline)
(define-key jv-basic-edit-mode-map (kbd "M-S-<down>") 'duplicate-line-down )
(define-key jv-basic-edit-mode-map (kbd "M-S-<up>" ) 'duplicate-line-up)
(define-key jv-basic-edit-mode-map (kbd "M-<down>")'swapline-down )
(define-key jv-basic-edit-mode-map (kbd "M-<up>")  'swapline-up )

;;register keybingings map (associate with this mode) 
(add-to-list 'minor-mode-map-alist ( cons 'jv-basic-edit-mode jv-basic-edit-mode-map))

#+end_src

#+begin_src emacs-lisp
;;register minor mode
(add-to-list 'minor-mode-alist '(jv-basic-edit-mode " jv-basic-edit"))
#+end_src

#+begin_src emacs-lisp
(defun jv-basic-edit-mode (&optional ARG)
  "jv-basic-edit-mode is a minor mode consisting of a few basic editing commands. If ARG positive number > 0  activate mode else deactivate.If ARG is 'toggle then toggle mode"
  (interactive (list 'toggle))
  (setq jv-basic-edit-mode
	(if (eq ARG 'toggle)
	    (not jv-basic-edit-mode)
	  (> ARG 0)))
  (if jv-basic-edit-mode
      (message "jv-basic-mode activated")
    (message "jv-basic-mode deactivated"))
  (run-hooks 'jv-basic-edit-mode-hook))
#+end_src 

** The commands
#+begin_src emacs-lisp
(defun open-newline (&optional n)
  "Opens a new line below current line even if cursor is in middle of current line.Move point to opened line. If N is set open n lines."
  (interactive "pNumber of lines to open: ")
  (goto-char (line-end-position))
	     (newline (or n 1)))
#+end_src

#+begin_src emacs-lisp
;; maybe refactor...
(defun copy-line ()
"Copy line(s) into kill-ring. "
(let ((beg (line-beginning-position))
      (end (line-end-position)))
    (save-excursion 
    (when mark-active
     (if (> (point) (mark))
 	 (setq beg (save-excursion (goto-char (mark)) (line-beginning-position)))
       (setq end (save-excursion (goto-char (mark)) (line-end-position)))))
     (copy-region-as-kill beg end))))
#+end_src

#+begin_src emacs-lisp
  (defun duplicate--line (&optional direction)
    "Duplicates line(s) of text in DIRECTION. if DIRECTION is 1  duplicate to line bellow else duplicate to line abbove current line." 
    (save-mark-and-excursion
      (copy-line)
      (open-newline)
      (yank))
    (when (eq direction 1)
      (next-line)))

  ;;Fixme only works once for selected region since loosing the marked area when doing next line
  (defun duplicate-line-down  ()
    "Creates newline(s) containing content of current line(s) below the current line. "
    (interactive)
    (duplicate--line 1))

(defun duplicate-line-up  ()
  "Creates  newline(s) containing content of current line(s) above the current line. "
  (interactive)
    (duplicate--line))
#+end_src

;; could cause problems on last line of buffer
;; could take advantage of exchange-point and mark?
;; beg and end delimits  single line at this point it might be first
;; (if point < mark) or last if (point > mark)
;; If point is after mark then end is correct but beg is beginnging of last line
;; mark is looking at characther on first line
;; if mark is after point end is currently last of first line and mark is at last line
#+begin_src emacs-lisp
(defun jv/kill--lines ()
  "Kill whole line(s). If mark is set kill all (whole)lines within region else kill line wher point is. "
  (let ((beg (line-beginning-position))
	(end (+ 1 (line-end-position))))
    (when mark-active
      (if (> (point)(mark))
	  (setq beg (save-excursion (goto-char (mark))(line-beginning-position)))
	(setq end (save-excursion (goto-char (mark)) (+ (line-end-position) 1)))))
    (kill-region beg end))
  )
#+end_src

;;Similar to finally clause. If next-line tries to go beyon end of buffer
  ;; We still want to yank back the killed line. 
#+begin_src emacs-lisp
;; FIXME region is lost when command is executed through keybindings. Hence can do it repeatadly
;; FIXME should barf on readonly buffers
(defun swapline-down ()
  "Transposes whole line(s) down. POINT is set to begining of moved line."
  (interactive)
  (jv/kill--lines)
  (unwind-protect
      (next-line)
    (progn 
      (beginning-of-line)
      ;; preserve current point
      (save-mark-and-excursion(yank)))))
#+end_src

#+begin_src emacs-lisp
(defun swapline-up ()
  "Transpose line(s) up."
  (interactive)
  (jv/kill--lines)
  (unwind-protect

      (previous-line)
    (progn
      (beginning-of-line)
      (save-mark-and-excursion(yank))
  )))
#+end_src

* Turning your code into package

Following code can be found at the top the file containing the minor mode. It turn the file into a simple package. You can read more about
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Packaging-Basics.html][creating simple packages]] in the Emacs manual.  =;;;=
is used to subdivide content of package. I think they use the term stylized comments for this. You can read about the the different headers etc [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html][here.]]


#+begin_src emacs-lisp

    ;;; jv-basic-edit.el --- Some basic text editing commands  -*- lexical-binding:t; -*-


    ;; Author: Janne Väisänen <janva415@gmail.com>
    ;; Created 26 Mar 2022
    ;; Version: 0.1

    ;; Keywords: elisp, textediting
    ;; URL:

    ;;; Commentary

    ;; This package provides the minor mode jv-basic-edit. It's a minimal package ;; consisting of a feew basic text editing commands such as copy whole line.  ;; This file is not part of GNU Emacs. This was part of me learning Elisp and how minor mode are built. Feel free to copy but be aware the code herein has its flaws and there are probably better solutions out there.

    ;; This file is free sofware...

    ;;;###autoload



  ;;; Code:

 (message "Package code goes here")

  
  ;;; jv-basic-edit.el ends here
#+end_src  

  Note your actuall package code should go in between  =;;;Code=  and 
 =jv-basic-edit.el ends here= where jv-basic-edit.el should be name of your package file.
 
#+begin_src emacs-lisp
(provide 'jv-basic-edit)
#+end_src

** Manually installing your package
In the future I might be using the [[https://github.com/raxod502/straight.el][straight package]]. This will enable to fetch and install the package from my github using usepackage package. In the meanwhile package installation will be done manually on my local system.  This can be done as follows.

#+begin_src emacs-lisp
  M-x package-install-file
#+end_src

This will prompt you for a file to install. The file has to be package see above to learn how to turn your code into package.

** Initilizing package in your init file

I currently use [[https://github.com/jwiegley/use-package][usepackage]] for my init files as it simplifies life. So following lines will load the package and start the mode  when i run my emacs.

#+begin_src emacs-lisp
  (use-package jv-basic-edit
    :ensure nil
    :config (jv-basic-edit-mode 1))
#+end_src

I use =:ensure nil= here to make sure it doesn't try download it from any repositories as I currently only install it manuall y on my local system.
